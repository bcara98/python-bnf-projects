#!/usr/bin/env python3

#Description: This program uses a local version of blast (must be installed for the program to run) to detect orthologus sequences (in this case defined as those blasted both ways). 
#             It takes to fasta files (either nucleotides or amino acids) and it generates a corresponding database for each fasta file. Then a local blast is run with one of the 
#             fasta files being the query and the database generated by the other fasta file as the database and vice versa. Pairs of sequences that had a blast match both ways 
#             were determined as orthologous and are saved as an output file
             
import argparse
import subprocess
import os

#parses the command line aruments in the specified format -i1 first input file -i2 second input file -o output filename -t blast type
parser = argparse.ArgumentParser(description="Find sets of ortholog genes")
parser.add_argument('-i1',metavar='--input1',type=str,help='Enter the first input fasta file')
parser.add_argument('-i2',metavar='--input2',type=str,help='Enter the secondss input fasta file')
parser.add_argument('-o',metavar='--output',type=str,help='Enter the name of the output file')
parser.add_argument('-t',metavar='--type',type=str,help='Enter the sequence type <n> for nucleotide <p> for protein')

args = parser.parse_args()

#helper function to check the validity of the arguments (like if input file exists or blast type is valid) returns True only if all arguments are valid
def check_arguments(input1,input2,type_seq):
    check=[True,True,True] #tracks which arguments are valid, values will become false if invalid
    #checks if input file paths are valid
    if not os.path.exists(input1):
        check[0] = False
    if not os.path.exists(input2):
        check[1] = False
    #checks if blast type is valid (protein, nucleotide)
    if type_seq != 'n' and type_seq != 'p':
        check[2] = False
    valid = True #variable keeps track if all arguments are valid

    #loop scans the check list if an element in the list is false then the valid variable becomes false too
    #also uses a switch statement to print which arguments are invalid
    for i in range(0,len(check)):
        if check[i] == False:
            valid = False
            switch={
                0:'Error: The first input file does not exist!',
                1:'Error: The second input file does not exist!',
                2:'Error: Invalid sequence type must be either <n> or <p>'
            }
            print(switch.get(i,''))
    return valid #returns the valid variable
    
#helper function to detect the type of database to generate later (protein or nucleotide)
def get_type(type_seq):
    if type_seq == 'n':
        return 'nucl'
    else:
        return 'prot'

#checks if all arguments are valid if not Error message is pritned and program exits
valid = check_arguments(args.i1, args.i2, args.t) 
if valid == False:
    exit(1)

#gets the type of database to generate and stores the proper flag into the dbtype_str string for the makeblastdb command
dbtype_str = get_type(args.t)

#helper wrapper function that calls the makeblastdb command with the proper arguments and flags (input file name and database type)
def make_database(input_file,type_seq=dbtype_str):
    create_database = subprocess.run(['makeblastdb','-in',input_file,'-dbtype',dbtype_str,'-parse_seqids','-hash_index'],stdout=subprocess.DEVNULL,stderr=subprocess.DEVNULL)

#helper wrapper function that calls the blast command (either blastp when type is set to protein [-t p] or blastn when set for nucleotides [-t n])
#with the proper arguments and flags (query file, database file, and blast type)
def blast(query,database,type_seq):
    if type_seq == 'nucl':
        do_blast = subprocess.run(['blastn','-query',query,'-db',database,'-max_target_seqs','1'],capture_output=True,encoding='UTF-8')
    else:
        do_blast = subprocess.run(['blastp','-query',query,'-db',database,'-max_target_seqs','1'],capture_output=True,encoding='UTF-8')
    return do_blast #returns the output of the blast command to be proccessed later

#helper function that removes any intermediate files from the database generation, used at the end of the program
def remove_intermediate_files(input_file):
    ext = ['to','os','hd','db','hi','hr','in','js','og','ot','sq','tf']
    for i in ext:
        if os.path.exists(input_file+'.'+args.t+i):
            os.remove(input_file+'.'+args.t+i)

#helper functions below are used to help process the blast ouput and extract the needed information

#helper function the find caharcter occurences within a string and returns their index positon
def find_chars(ch,string):
    pos = []
    for i in range(0,len(string)):
        if string[i] == ch:
            pos.append(i)
    return pos

#helper function to get the query gene name from blast output as it scans said output line by line
def get_query_name(query_string):
    pos = find_chars(' ', query_string) #uses space character as anchor to find the gene name within the full string
    return query_string[pos[0]+1:pos[1]] #returns the substring that contains the gene name

#helper function to return the gene names of the significant hits from the blast with a query gene
def get_hit_names(hit_string):
    pos = find_chars(' ', hit_string) #uses space character as anchor to find the gene name within the full string
    return hit_string[0:pos[0]] #returns substring that contains the gene name

#helper function that removes empty strings from a list of strings returns a trimmed list with only non-empty strings
def trim_lines(lines):
    trimmed = []
    for i in range(0,len(lines)):
        if len(lines[i]) != 0:
            trimmed.append(lines[i])
    return trimmed

#helper function processes the ouput from the blast that is presented as a list of lines
def process_blast(line_list):
    line_list = trim_lines(line_list) #empty strings are removed from the line list
    #triggers help detect whenether a query or a hit is found. Values are set in this order [Found Query, Approaching Hit Gene, Got to the end of the hit genes]
    triggers = [False,False,False] 
    matches = {} #dictionary stores the matches [key=query gene,value=hit gene]
    last_query = '' #initialize last found query as empty string

    #scans the line list containing the blast output
    for i in line_list:

        #if a query gene is found for the first time based on the triggers list extract query gene and add to dictionary as a key with empty value
        if i.find('Query=') != -1 and triggers[0] == False and triggers[1] == False:
            last_query = get_query_name(i)
            matches[last_query] = []
            triggers[0] = True
            continue

        #if no hits have been detected for query gene reset triggers to False and delete query gene from dictionary
        if i == '***** No hits found *****' and triggers[0] == True:
            triggers[0] = False
            matches.pop(last_query)
            continue

        #if query gene has already been found and string indicating significant alignments is also found set triggers[1] to true (Aproaching hit gene)
        if i.find('Sequences producing significant alignments:') != -1 and triggers[0] == True and triggers[1] == False:
            triggers[1] = True
            continue

        #if query gene is found and a hit gene is approached extract the hit genes from the subsequent lines until a line starting with '>' is reached
        if triggers[0] == True and triggers[1] == True and triggers[2] == False:
            #if line starts '>' trigger[2] is set to true (Got to the end of the hit genes)
            if i[0] == '>':
                triggers[2] = True
            else:
                matches[last_query]='lcl|'+get_hit_names(i) #else get hit gene names from each line and add it to the dictionary as a value with its corresponding query as key

        #if all triggers are set to true (found query, and scanned all the hit genes) they reset to false for the next query-hit match        
        if triggers[0] == True and triggers[1] == True and triggers[2] == True:
            triggers[0] = False
            triggers[1] = False
            triggers[2] = False
    return matches #dictionary containing the matches is returned

#helper function to detect orthologous genes (which blast reciprocally). It gets 2 dictionaries as input with blast matches
def detect_orthologous(match1,match2):
    ortho_match = [] #list will store all the orthologous genes
    keys = list(match1.keys()) #keys from the first blast match (containing queries) dictionary are copied to a list

    #for loop scans all the query keys
    for i in keys:
        #checks if databse hit gene from corresponding query from match1 exists as a key in the match2 dictionary
        if match1[i] in match2:
            #if it exists it then checks if that value of the match2 dictianry is the same as the query key in the match1 dictionary
            if i == match2[match1[i]]:
                ortho_match.append([i,match1[i]]) #if it matches then both the query and databse gene are appended to the orthologous list
    return ortho_match #returns the orthologou list

#blast is performed 2 times with one of the files being the query and the other the database and vice versa

#this is the first blast
make_database(args.i2) #creates a blast databse from the -i2 input file
info1 = blast(args.i1,args.i2,dbtype_str) #blasts the -i1 file as query and -i2 file as the database
lines1 = info1.stdout.split('\n') #gets the blast ouput into a lines list that splits it based on newline characters
matches_1 = process_blast(lines1) #gets the blast (query-hit gene) matches and stores them into the matches1 dictionary
hits1 = len(matches_1) #length of dictionary are the number of hits for the first blast
remove_intermediate_files(args.i2) #removes the generated database files

#this is the second blast
make_database(args.i1) #creates a blast databse from the -i1 input file
info2 = blast(args.i2,args.i1,dbtype_str) #blasts the -i2 file as query and -i1 file as the database
lines2 = info2.stdout.split('\n') #gets the blast ouput into a lines list that splits it based on newline characters
matches_2 = process_blast(lines2) #gets the blast (query-hit gene) matches and stores them into the matches2 dictionary
hits2 = len(matches_2) #length of dictionary are the number of hits for the second blast
remove_intermediate_files(args.i1) #removes the generated database files

#scans for orthoogus genes based on the 2 blast matches
ortho_match = detect_orthologous(matches_1, matches_2)
ortho_gen_num = len(ortho_match) #length of list is the number of orthologus genes

#create files to store the needed output file containing the orthologous genes
output = open(args.o,'w')
for i in ortho_match:
    output.write(str(i[0])+"\t"+str(i[1])+'\n')
output.close()

#create a README file to store the hit and orthologous gene numbers
readme = open('README.txt','w')
readme.write('Hits when blasting [Query='+args.i1+'] and [Database='+args.i2+']: '+str(hits1)+'\n')
readme.write('Hits when blasting [Query='+args.i2+'] and [Database='+args.i1+']: '+str(hits2)+'\n')
readme.write('Total number of hits: '+str(hits1+hits2)+'\n')
readme.write('Number of orthologus genes: '+str(ortho_gen_num)+'\n')
readme.close()
